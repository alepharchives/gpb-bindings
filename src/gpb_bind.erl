%% Copyright (c) 2012 Martin Donath <md@struct.cc>

%% Permission is hereby granted, free of charge, to any person obtaining a copy
%% of this software and associated documentation files (the "Software"), to
%% deal in the Software without restriction, including without limitation the
%% rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
%% sell copies of the Software, and to permit persons to whom the Software is
%% furnished to do so, subject to the following conditions:

%% The above copyright notice and this permission notice shall be included in
%% all copies or substantial portions of the Software.

%% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
%% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
%% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
%% IN THE SOFTWARE.

-module(gpb_bind).
-author('Martin Donath <md@struct.cc>').

% Include necessary libraries.
-include_lib("kernel/include/file.hrl").
-include_lib("gpb/include/gpb.hrl").

% Public functions.
-export([file/2]).

%% ----------------------------------------------------------------------------
%% Macros
%% ----------------------------------------------------------------------------

% Current version of this module.
-define(VERSION, "0.1.0").

% Subdirectory for modules that handle conversion of records from and to
% Protobuf binaries, as well as pre- and suffixes of the generated modules.
-define(PB_SUBDIR, "pb").
-define(PB_PREFIX, "").
-define(PB_SUFFIX, "_pb").

% Subdirectory for modules that contain bindings for the records generated by
% gpb, as well as pre- and suffixes of the generated modules.
-define(PB_BIND_SUBDIR, "pb_bind").
-define(PB_BIND_PREFIX, "").
-define(PB_BIND_SUFFIX, "").

%% ----------------------------------------------------------------------------
%% Public functions
%% ----------------------------------------------------------------------------

% Extract the message definitions from the given Protobuf file and compile them
% to record definitions. Then, analyze those message definitions to find out
% which messages reference each other in order to find the roots, which are
% simply the top-level messages in the Protobuf file. Example:
%
%   jobs.proto:
%
%     message Address {
%       required string street = 1;
%       required string city = 2;
%     }
%
%     message Person {
%       required string name = 1;
%       required Address address = 2;
%     }
%
%     message Job {
%       required string title = 1;
%       required string description = 2;
%     }
%
%     message Company {
%       required string name = 1;
%       repeated Job jobs = 2;
%     }
%
% Of those four message types, only Person and Company are roots, as they are
% not referenced in another message. Job and Address are referenced in Company
% and Person, so they are not considered of being a root. For each of those
% root message types, bindings are generated, e.g. for Person, those are:
%
%   person.erl:
%
%     name_get/1,                 person:name_get(Person)
%     name_set/2,                 person:name_get(Person, Value)
%     address_street_get/1        person:address_street_get(Person)
%     address_street_set/2        person:address_street_set(Person, Value)
%     address_city_get/1          person:address_city_get(Person)
%     address_city_set/2          person:address_city_set(Person, Value)
%
% Messages, which are referenced inside other messages and marked as 'optional'
% or 'required' get inlined, thus able to represent deeply nested hierarchies.
% This is, where this module really shines, as Erlang's syntax on nested
% records is really, really ugly!
%
% If a message can contain many instances of another message, thus its
% occurrence is declared 'repeated', a separate module is declared. As a
% company can offer many jobs, a set of bindings is generated which is split
% across two modules:
% 
%   job.erl
%
%     title_get/1,                job:title_get(Job)
%     title_set/2,                job:title_get(Job, Value)
%     description_get/1,          job:description_get(Job)
%     description_set/2,          job:description_get(Job, Value)
%
%   company.erl
%
%     name_get/1,                 company:name_get(Company)
%     name_set/2,                 company:name_get(Company, Value)
%     jobs_get/1,                 company:jobs_get(Company)
%     jobs_set/2,                 company:jobs_get(Company, Value)
%     jobs_add/2,                 company:jobs_add(Company, Value)
%
% For repeatedly nested messages, a list of records is returned. Those records
% can then be manipulated individually with a separate module, and persisted
% within the referencing message with a simple set operation. A third method
% to add (prepend) a new nested record is also provided.
%
% These separate declarations are also generated upon nested message which are
% marked as 'repeated', e.g.:
%
%   jobs.proto:
% 
%     message Company {
%       message Job {
%         required string title = 1;
%         required string description = 2;
%       }
%       required string name = 1;
%       required Job jobs = 2
%     }
%
% This will expand to the same definitions as stated above, except that the
% names of the modules are also nested, resulting in 'company.erl' and
% 'company_job.erl', in order to avoid clashing namespaces across modules with
% the same message type names.
%
% The modules generated by gpb, which handle the conversion of records from and
% to binaries, and those generated by this module are stored in separate
% subdirectories. The former are named after the Protobuf file, the names of
% the latter are expanded from the message types.
%
% Beside those bindings, three functions for creating, encoding and decoding
% records are generated, namingly:
%
%   person.erl:
%
%     new/0,                      person:new()
%     encode/1, encode/2          person:encode(Person[, Opts])
%     decode/1,                   person:decode(Person)
%
% All in all this is an easy and convenient way of handling arbitrarily deep
% nested Protobuf message type definitions.
file(File, Opts) ->
  case gpb_compile:file(File, [to_msg_defs | Opts]) of
    { ok, Defs } ->
      Output = proplists:get_value(o, Opts, filename:dirname(File)),
      File   = filename:basename(File, filename:extension(File)),
      case directory(Output, ?PB_SUBDIR) of
        { error, Reason } ->
          { error, Reason };
        Path ->
          Module = list_to_atom(?PB_PREFIX ++ File ++ ?PB_SUFFIX),
          gpb_compile:msg_defs(Module, Defs,
            [{ o, Path } | proplists:delete(o, Opts)]),
          each(roots(Defs), Defs, [{ m, Module } | Opts])
      end;
    { error, Reason } ->
      { error, Reason }
  end.

%% ----------------------------------------------------------------------------
%% Top-level generators
%% ----------------------------------------------------------------------------

% Iterate through the given list of root message type definitions, and generate
% bindings for each of them.
each([], _Defs, _Opts) ->
  ok;
each([{ { msg, Type }, Fields } | Roots], Defs, Opts) ->
  case generate(Type, Defs, Fields, Opts) of
    ok ->
      each(Roots, Defs, Opts);
    { error, Reason } ->
      { error, Reason }
  end.

% Generate the source code for the provided base and all of its nested message
% types, and save the contents to a file in the bindings subdirectory.
generate(Base, Defs, Fields, Opts) ->
  Output = proplists:get_value(o, Opts, filename:dirname(Opts)),
  File   = ?PB_BIND_PREFIX ++ filename(Base) ++ ?PB_BIND_SUFFIX,
  case directory(Output, ?PB_BIND_SUBDIR) of
    { error, Reason } ->
      { error, Reason };
    Path ->
      file:write_file(f("~s~s.erl", [Path, File]), [
        f("~s~n", [head(Base, Defs, Fields, Opts)]),
        f("~s", [body(Base, Defs, Fields, Opts, [])]) ])
  end.

% Generate the function bodies of the source file for the provided set of
% message definitions and do this recursively for nested definitions.
body(_Base, _Defs, [], _Opts, _Parents) ->
  [];
body(Base, Defs, [Field = #field{} | Fields], Opts, Parents) ->
  case { Field#field.type, Field#field.occurrence } of
    { { msg, Type }, repeated } ->
      Children = proplists:get_value({ msg, Type }, Defs),
      generate(Type, Defs, Children, Opts),
      [ f("~s~2n", [function_get(Base, [Field#field{ type = Type } | Parents])]),
        f("~s~2n", [function_set(Base, [Field#field{ type = Type } | Parents])]),
        f("~s~2n", [function_add(Base, [Field#field{ type = Type } | Parents])]) |
        body(Base, Defs, Fields, Opts, Parents) ];
    { { msg, Type }, _ } ->
      Children = proplists:get_value({ msg, Type }, Defs),
      body(Base, Defs, Children, Opts, [Field | Parents]) ++
      body(Base, Defs, Fields, Opts, Parents);
    _ ->
      [ f("~s~2n", [function_get(Base, [Field | Parents])]),
        f("~s~2n", [function_set(Base, [Field | Parents])]) |
        body(Base, Defs, Fields, Opts, Parents) ]
  end.

% Generate the head section of the source file for the provided base/definition
% combination, including exports and functions for encoding and decoding.
head(Base, Defs, Fields, Opts) ->
  Module = proplists:get_value(m, Opts),
  [ f("%% Automatically generated, do not edit~n"),
    f("%% Generated by ~s version ~s on ~p~n", [
      ?MODULE, ?VERSION, calendar:local_time()]),
    f("-module(~s).~2n", [?PB_BIND_PREFIX ++
      filename(Base) ++ ?PB_BIND_SUFFIX]),

    % Generic and specific exports.
    f("-export([new/0]).~n"),
    f("-export([encode/1, encode/2]).~n"),
    f("-export([decode/1]). ~2n"),
    f("~s~n", [exports(Base, Defs, Fields)]),

    % Include record definitions.
    f("-include(\"../~s/~s.hrl\").~2n", [?PB_SUBDIR, Module]),

    % Record creation.
    f("% Create new ~s.~n", [variable(Base)]),
    f("new()->~n"),
    f("  #~p{}.~2n", [Base]),

    % Record encoding.
    f("% Record -> Binary.~n"),
    f("encode(~s)->~n", [variable(Base)]),
    f("  encode(~s, [verify]).~n", [variable(Base)]),
    f("encode(~s, Opts)->~n", [variable(Base)]),
    f("  ~s:encode_msg(~s, Opts).~2n", [Module, variable(Base)]),

    % Record decoding.
    f("% Binary -> Record.~n"),
    f("decode(Binary)->~n"),
    f("  ~s:decode_msg(Binary, ~p).~n", [Module, Base]) ].

% Generate export statements for the provided list of field definitions. For
% each field, there is a getter and setter to be exported.
exports(Base, Defs, Fields) ->
  exports(Base, Defs, Fields, []).
exports(_Base, _Defs, [], _Parents) ->
  [];
exports(Base, Defs, [Field | Fields], Parents) ->
  case { Field#field.type, Field#field.occurrence } of
    { _, repeated } ->
      [ f("-export([~s_get/1]).~n", [function_name([Field | Parents])]),
        f("-export([~s_set/2]).~n", [function_name([Field | Parents])]),
        f("-export([~s_add/2]).~n", [function_name([Field | Parents])]) |
        exports(Base, Defs, Fields, Parents) ];
    { { msg, Type }, _ } ->
      Children = proplists:get_value({ msg, Type }, Defs),
      exports(Base, Defs, Children, [Field | Parents]) ++
      exports(Base, Defs, Fields, Parents);
    _ ->
      [ f("-export([~s_get/1]).~n", [function_name([Field | Parents])]),
        f("-export([~s_set/2]).~n", [function_name([Field | Parents])]) |
        exports(Base, Defs, Fields, Parents) ]
  end.

%% ----------------------------------------------------------------------------
%% Get generators
%% ----------------------------------------------------------------------------

% Generate the head of a function to retrieve a certain field. Furthermore,
% quote the respective section in the proto file for reference.
function_get_head(Base, Fields) ->
  [ f("~s~n", [function_comment(Base, Fields)]),
    f("~s_get(~s) ->", [function_name(Fields), variable(Base)]) ].

% Generate the body of a function to retrieve a certain field. If any of the
% parent records is missing, undefined is returned.
function_get_body(Base, Fields, 0, _Value) ->
  [ f("~s", [record_get(Base, Fields)]) ];
function_get_body(Base, Fields, Layer, Value) ->
  [ f("case ~s of~n", [record_get(Base, drop(Fields, Layer))]),
    f("  undefined ->~n"),
    f("    undefined;~n"),
    f("  _ ->~n"),
    f("    ~s~n", [Value]),
    f("end") ].

% Generate a get function for the provided base and field list, including a
% header and nested/inlined function bodies for each field layer.
function_get(Base, Fields) ->
  function_get(Base, Fields, record_get(Base, Fields)).
function_get(Base, Fields, Value) ->
  function_get(Base, Fields, 0, Value).
function_get(Base, Fields, Layer, Value) ->
  case length(Fields) of
    Layer ->
      lists:concat([
        f("~s~n", [lists:concat(function_get_head(Base, Fields))]),
        f("~s~s.", [indent(1), Value])]);
    _ ->
      function_get(Base, Fields, Layer + 1,
        inline(function_get_body(Base, Fields, Layer, Value), Fields, Layer))
  end.

%% ----------------------------------------------------------------------------
%% Set generators
%% ----------------------------------------------------------------------------

% Generate the head of a function to persist a value to a certain field. Also,
% quote the respective section in the proto file for reference.
function_set_head(Base, Fields) ->
  [ f("~s~n", [function_comment(Base, Fields)]),
    f("~s_set(~s, ~s) when ~s ->", [function_name(Fields), variable(Base),
      v(), function_guards(hd(Fields))]) ].

% Generate the body of a function to persist a value to a certain field. Parent
% records are initialized transparently.
function_set_body(Base, Fields, 0, _Value) ->
  [ f("~s", [record_set(Base, Fields, 1)]) ];
function_set_body(Base, Fields, Layer, Value) ->
  [ f("case ~s of~n", [record_get(Base, drop(Fields, Layer))]),
    f("  undefined ->~n"),
    f("    ~s;~n", [record_set(Base, Fields, Layer + 1)]),
    f("  ~s ->~n", [[65 + length(Fields) - Layer - 1]]),
    f("    ~s~n", [Value]),
    f("end") ].

% Generate a function footer, returning an argument error, in case the value
% does not pass through the respective guards.
function_set_foot(Base, Fields) ->
  [ f("~s_set(_~s, _~s) ->~n", [function_name(Fields), variable(Base), v()]),
    f("  { error, badarg }") ].

% Generate a set function for the provided base and field list, including a
% header and nested/inlined function bodies for each field layer.
function_set(Base, Fields) ->
  function_set(Base, Fields, record_set(Base, Fields, length(Fields) - 1)).
function_set(Base, Fields, Value) ->
  function_set(Base, Fields, 0, Value).
function_set(Base, Fields, Layer, Value) ->
  case length(Fields) of
    Layer ->
      lists:concat([
        f("~s~n", [lists:concat(function_set_head(Base, Fields))]),
        f("~s~s;~n", [indent(1), Value]),
        f("~s.", [lists:concat(function_set_foot(Base, Fields))])
      ]);
    _ ->
      function_set(Base, Fields, Layer + 1,
        inline(function_set_body(Base, Fields, Layer, Value), Fields, Layer))
  end.

%% ----------------------------------------------------------------------------
%% Add generators
%% ----------------------------------------------------------------------------

% Generate the head of a function to prepend a value to a certain field. Also,
% quote the respective section in the proto file for reference.
function_add_head(Base, Fields = [Field | _]) ->
  [ f("~s~n", [function_comment(Base, Fields)]),
    f("~s_add(~s, ~s) when ~s ->", [function_name(Fields), variable(Base),
      v(), f("is_record(~s, ~p)", [v(), Field#field.type])]) ].

% Generate the body of a function to prepend a value to a certain field. Parent
% records are initialized transparently.
function_add_body(Base, Fields, 0, _Value) ->
  [ f("case ~s of~n", [record_get(Base, Fields)]),
    f("  undefined ->~n"),
    f("    ~s;~n", [record_set(Base, Fields, 1, f("[~s]", [v()]))]),
    f("  V ->~n"),
    f("    ~s~n", [record_set(Base, Fields, 1, f("[~s | V]", [v()]))]),
    f("end") ];
function_add_body(Base, Fields, Layer, Value) ->
  [ f("case ~s of~n", [record_get(Base, drop(Fields, Layer))]),
    f("  undefined ->~n"),
    f("    ~s;~n", [record_set(Base, Fields, Layer + 1)]),
    f("  ~s ->~n", [[65 + length(Fields) - Layer - 1]]),
    f("    ~s~n", [Value]),
    f("end") ].

% Generate a function footer, returning an argument error, in case the value
% does not pass through the respective guards.
function_add_foot(Base, Fields) ->
  [ f("~s_add(_~s, _~s) ->~n", [function_name(Fields), variable(Base), v()]),
    f("  { error, badarg }") ].

% Generate an add function for the provided base and field list, including a
% header and nested/inlined function bodies for each field layer.
function_add(Base, Fields) ->
  function_add(Base, Fields, record_set(Base, Fields, length(Fields) - 1)).
function_add(Base, Fields, Value) ->
  function_add(Base, Fields, 0, Value).
function_add(Base, Fields, Layer, Value) ->
  case length(Fields) of
    Layer ->
      lists:concat([
        f("~s~n", [lists:concat(function_add_head(Base, Fields))]),
        f("~s~s;~n", [indent(1), Value]),
        f("~s.", [lists:concat(function_add_foot(Base, Fields))])
      ]);
    _ ->
      function_add(Base, Fields, Layer + 1,
        inline(function_add_body(Base, Fields, Layer, Value), Fields, Layer))
  end.

%% ----------------------------------------------------------------------------
%% Signature generators
%% ----------------------------------------------------------------------------

% Generate a comment section for the provided base and field list which
% references the respective definition in the proto file.
function_comment(_Base, [First, Second | _]) ->
  { msg, Type } = Second#field.type,
  f("% ~s { ~p ~s ~p = ~p; }", [atom_to_list(Type), First#field.occurrence,
    atom_to_list(First#field.type), First#field.name, First#field.rnum]);
function_comment(Base, [First | _]) ->
  f("% ~s { ~p ~s ~p = ~p; }", [atom_to_list(Base), First#field.occurrence,
    atom_to_list(First#field.type), First#field.name, First#field.rnum]).

% Generate a function name for the provided field list which is basically
% just the identifiers concatenated with an underscore.
function_name(Fields) ->
  string:join([ atom_to_list(Field#field.name) ||
    Field <- lists:reverse(Fields)], "_").

% Generate guard(s) for the provided field, whereas the Protobuf types have
% to be mapped to the internal Erlang types.
function_guards(Field) ->
  function_guards(Field, v()).
function_guards(#field{ type = int32 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = int64 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = uint32 }, Value) ->
  f("is_integer(~s), ~s >= 0", [Value, Value]);
function_guards(#field{ type = uint64 }, Value) ->
  f("is_integer(~s), ~s >= 0", [Value, Value]);
function_guards(#field{ type = sint32 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = sint64 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = fixed32 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = fixed64 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = sfixed32 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = sfixed64 }, Value) ->
  f("is_integer(~s)", [Value]);
function_guards(#field{ type = bool }, Value) ->
  f("is_boolean(~s)", [Value]);
function_guards(#field{ type = float }, Value) ->
  f("is_float(~s)", [Value]);
function_guards(#field{ type = double }, Value) ->
  f("is_float(~s)", [Value]);
function_guards(#field{ type = string }, Value) ->
  f("is_list(~s)", [Value]);
function_guards(#field{ type = bytes }, Value) ->
  f("is_binary(~s)", [Value]);
function_guards(_Field, Value) ->
  f("is_list(~s)", [Value]).

%% ----------------------------------------------------------------------------
%% Record qualifiers
%% ----------------------------------------------------------------------------

% Qualify a nested record chain by resolving each field, in order to get the
% current type, and append the already qualified string.
record_get(Base, Fields) ->
  record_get(Base, Fields, "").
record_get(Base, [], Value) ->
  f("~s#~p~s", [variable(Base), Base, Value]);
record_get(Base, [Field | Fields], Value) ->
  record_get(Base, Fields, case { Field#field.type, Value } of
    { { msg, _ }, "" } ->
      f(".~p", [Field#field.name]);
    { { msg, Type }, _ } ->
      f(".~p#~p~s", [Field#field.name, Type, Value]);
    _ ->
      f(".~p~s", [Field#field.name, Value])
  end).

% Qualify a nested record chain by resolving each field, in order to set the
% current type, and append the already qualified string.
record_set(Base, Fields, Layer) ->
  record_set(Base, Fields, Layer, v()).
record_set(Base, [], _Layer, Value) ->
  f("~s#~p~s", [variable(Base), Base, Value]);
record_set(Base, [Field = #field{ name = Name } | Fields], Layer, Value) ->
  record_set(Base, Fields, Layer - 1, case Field#field.type of
    { msg, Type } when Layer =< 0 ->
      f("{ ~p = ~s#~p~s }", [Name, [65 + length(Fields)], Type, Value]);
    { msg, Type } when Layer  > 0 ->
      f("{ ~p = #~p~s }", [Name, Type, Value]);
    _ ->
      f("{ ~p = ~s }", [Name, Value])
  end).

%% ----------------------------------------------------------------------------
%% Helper functions
%% ----------------------------------------------------------------------------

% Iterate through the provided list of definitions and remove all definitions
% that are referenced in other definitions in order to obtain the roots.
roots(Defs) ->
  roots(Defs, Defs, []).
roots(Defs, [], []) ->
  Defs;
roots(Defs, [{ _Type, Fields } | Messages], []) ->
  roots(Defs, Messages, Fields);
roots(Defs, Messages, [Field | Fields]) ->
  case Field#field.type of
    { msg, Type } ->
      roots(proplists:delete({ msg, Type }, Defs), Messages, Fields);
    _ ->
      roots(Defs, Messages, Fields)
  end.

% Helper function to drop the first N elements of a list. The trivial case of
% dropping 0 elements is implemented for convenient use.
drop(List, 0) ->
  List;
drop([_ | List], N) ->
  drop(List, N - 1).

% Emit the given amount of whitespaces for indentation of strings, whereas the
% provided number is multiplied by 2 for nice code formatting.
indent(N) ->
  lists:flatten(lists:duplicate(N * 2, " ")).

% Given a list of fields, indent all of them except the first by the correct
% amount applicable for the given layer.
inline([Head | Tail], Fields, Layer) ->
  lists:concat([Head | [ f("~s~s", [
    indent((length(Fields) - Layer) * 2 - 1), Line]) || Line <- Tail ]]).

% Split the atom (Noisiaaa!) at dots and return the last part as a string.
% This is necessary for resolving the variable name of the given base.
variable(Base) ->
  lists:last(string:tokens(atom_to_list(Base), ".")).

% Convert the atom to a filename representation, replacing dots by underscores
% and downcasing the whole string.
filename(Base) ->
  string:to_lower(string:join(string:tokens(atom_to_list(Base), "."), "_")).

% Check if the given base directory exists, create a sub-directory for the
% provided identifier and return its name.
directory(Base, Sub) ->
  case filelib:is_dir(Base) of
    true  ->
      Path = Base ++ "/" ++ Sub ++ "/",
      filelib:ensure_dir(Path), Path;
    false ->
      { error, enodir }
  end.

% Wrapper for io_lib:format/2, which formats a string and (optionally) inserts
% values that can be provide as arguments.
f(String) ->
  f(String, []).
f(String, Args) ->
  io_lib:format(String, Args).

% Return the generic variable name, which is used within all generated methods
% for values of varying types.
v() ->
  "Value".