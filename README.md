# Google Protocol Buffer Bindings

Extract the message definitions from the given Protobuf file and compile them
to record definitions. Then, analyze those message definitions to find out
which messages reference each other in order to find the roots, which are
simply the top-level messages in the Protobuf file. Example:

``` javascript

    // jobs.proto:

    message Address {
      required string street = 1;
      required string city = 2;
    }

    message Person {
      required string name = 1;
      required Address address = 2;
    }

    message Job {
      required string title = 1;
      required string description = 2;
    }

    message Company {
      required string name = 1;
      repeated Job jobs = 2;
    }
```

Of those four message types, only Person and Company are roots, as they are
not referenced in another message. Job and Address are referenced in Company
and Person, so they are not considered of being a root. For each of those
root message types, bindings are generated, e.g. for Person, those are:

``` javascript

    // person.erl:

    name_get/1,                 person:name_get(Person)
    name_set/2,                 person:name_get(Person, Value)
    address_street_get/1        person:address_street_get(Person)
    address_street_set/2        person:address_street_set(Person, Value)
    address_city_get/1          person:address_city_get(Person)
    address_city_set/2          person:address_city_set(Person, Value)

```

Messages, which are referenced inside other messages and marked as 'optional'
or 'required' get inlined, thus able to represent deeply nested hierarchies.
This is, where this module really shines, as Erlang's syntax on nested
records is really, really ugly!

If a message can contain many instances of another message, thus its
occurrence is declared 'repeated', a separate module is declared. As a
company can offer many jobs, a set of bindings is generated which is split
across two modules:

``` javascript

    // job.erl:

    title_get/1,                job:title_get(Job)
    title_set/2,                job:title_get(Job, Value)
    description_get/1,          job:description_get(Job)
    description_set/2,          job:description_get(Job, Value)

    // company.erl:

    name_get/1,                 company:name_get(Company)
    name_set/2,                 company:name_get(Company, Value)
    jobs_get/1,                 company:jobs_get(Company)
    jobs_set/2,                 company:jobs_get(Company, Value)
    jobs_add/2,                 company:jobs_add(Company, Value)

```

For repeatedly nested messages, a list of records is returned. Those records
can then be manipulated individually with a separate module, and persisted
within the referencing message with a simple set operation. A third method
to add (prepend) a new nested record is also provided.

These separate declarations are also generated upon nested message which are
marked as 'repeated', e.g.:

``` javascript

    // jobs.proto:

    message Company {
      message Job {
        required string title = 1;
        required string description = 2;
      }
      required string name = 1;
      repeated Job jobs = 2
    }

```

This will expand to the same definitions as stated above, except that the
names of the modules are also nested, resulting in 'company.erl' and
'company_job.erl', in order to avoid clashing namespaces across modules with
the same message type names.

The modules generated by gpb, which handle the conversion of records from and
to binaries, and those generated by this module are stored in separate
subdirectories. The former are named after the Protobuf file, the names of
the latter are expanded from the message types.

Beside those bindings, three functions for creating, encoding and decoding
records are generated, namingly:

``` javascript

    // person.erl:

    new/0,                      person:new()
    encode/1, encode/2          person:encode(Person[, Opts])
    decode/1,                   person:decode(Person)

```

All in all this is an easy and convenient way of handling arbitrarily deep
nested Protobuf message type definitions.